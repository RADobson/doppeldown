---
phase: 02-scanning-hardening
plan: 03
type: execute
wave: 3
depends_on: ["02-02"]
files_modified:
  - src/lib/domain-generator.ts
  - src/lib/evidence-collector.ts
  - src/app/dashboard/brands/[id]/page.tsx
  - src/components/ScanProgress.tsx
autonomous: false

must_haves:
  truths:
    - "DNS checks in domain-generator use dnsQueue for rate limiting"
    - "Screenshot captures use screenshotQueue for rate limiting"
    - "UI shows scan progress as percentage with current step"
    - "User can see which step the scan is on (domains, web, logo, social)"
    - "User can cancel an in-progress scan via cancel button"
    - "User can see retry status when scan is being retried"
  artifacts:
    - path: "src/lib/domain-generator.ts"
      provides: "Rate-limited DNS checks"
      contains: "dnsQueue"
    - path: "src/lib/evidence-collector.ts"
      provides: "Rate-limited screenshot capture"
      contains: "screenshotQueue"
    - path: "src/components/ScanProgress.tsx"
      provides: "Progress UI component with cancel"
      exports: ["ScanProgress"]
  key_links:
    - from: "src/lib/domain-generator.ts"
      to: "src/lib/scan-queue.ts"
      via: "import dnsQueue"
      pattern: "dnsQueue\\.add"
    - from: "src/lib/evidence-collector.ts"
      to: "src/lib/scan-queue.ts"
      via: "import screenshotQueue"
      pattern: "screenshotQueue\\.add"
    - from: "src/components/ScanProgress.tsx"
      to: "overall_progress"
      via: "percentage display"
      pattern: "overall_progress"
    - from: "src/components/ScanProgress.tsx"
      to: "/api/scan/cancel"
      via: "cancel button fetch"
      pattern: "api/scan/cancel"
---

<objective>
Integrate rate-limited queues into scanner modules and create progress UI showing percentage, current step, retry status, and cancel button.

Purpose: Complete the hardening by ensuring all external API calls go through queues, and users can see real-time progress and cancel scans.

Output: Updated scanners with queue integration, ScanProgress component showing percentage/step/retry with cancel functionality
</objective>

<execution_context>
@/home/dobsondev/.claude/get-shit-done/workflows/execute-plan.md
@/home/dobsondev/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/02-scanning-hardening/02-RESEARCH.md
@.planning/phases/02-scanning-hardening/02-CONTEXT.md
@src/lib/scan-queue.ts
@src/lib/domain-generator.ts
@src/lib/evidence-collector.ts
@src/app/api/scan/cancel/route.ts
</context>

<tasks>

<task type="auto">
  <name>Task 1: Integrate queues into domain-generator and evidence-collector</name>
  <files>src/lib/domain-generator.ts, src/lib/evidence-collector.ts</files>
  <action>
**VERIFIED:** Function names confirmed via grep:
- `checkDomainRegistration` exists at line 251 in domain-generator.ts
- `captureScreenshot` exists at line 158 in evidence-collector.ts
- `getWhoisData` exists at line 79 in evidence-collector.ts

**1. Update domain-generator.ts:**

Add import at top:
```typescript
import { dnsQueue } from './scan-queue';
```

Find the `checkDomainRegistration` function (line 251). It uses DNS over HTTPS to check domain registration. Wrap the internal fetch/DNS lookup with dnsQueue:

```typescript
export async function checkDomainRegistration(domain: string): Promise<boolean> {
  // Wrap the DNS lookup in rate-limited queue
  return dnsQueue.add(async () => {
    // ... existing implementation (keep all the DNS resolution logic)
  }) as Promise<boolean>;
}
```

Note: Move the entire function body inside the dnsQueue.add() callback. The queue handles rate limiting automatically.

**2. Update evidence-collector.ts:**

Add import at top:
```typescript
import { screenshotQueue, externalQueue } from './scan-queue';
```

Find the `captureScreenshot` function (line 158). Wrap Puppeteer calls:
```typescript
export async function captureScreenshot(url: string): Promise<{
  screenshot: Buffer | null;
  error?: string;
}> {
  return screenshotQueue.add(async () => {
    // ... existing Puppeteer screenshot logic (keep entire function body)
  }) as Promise<{ screenshot: Buffer | null; error?: string }>;
}
```

Find the `getWhoisData` function (line 79). Wrap with externalQueue:
```typescript
export async function getWhoisData(domain: string): Promise<WhoisData | null> {
  return externalQueue.add(async () => {
    // ... existing whois-json lookup (keep entire function body)
  }) as Promise<WhoisData | null>;
}
```

Note: The queues handle rate limiting automatically. Function signatures remain the same - callers don't need to change.
  </action>
  <verify>
    - `grep -n "dnsQueue" src/lib/domain-generator.ts` shows import and usage
    - `grep -n "screenshotQueue" src/lib/evidence-collector.ts` shows import and usage
    - `grep -n "externalQueue" src/lib/evidence-collector.ts` shows import and usage
    - `npx tsc --noEmit src/lib/domain-generator.ts src/lib/evidence-collector.ts` compiles
  </verify>
  <done>
    - domain-generator.ts uses dnsQueue for DNS lookups in checkDomainRegistration
    - evidence-collector.ts uses screenshotQueue for Puppeteer operations in captureScreenshot
    - evidence-collector.ts uses externalQueue for WHOIS lookups in getWhoisData
    - All files compile without TypeScript errors
  </done>
</task>

<task type="auto">
  <name>Task 2: Create ScanProgress component with percentage, step, retry, and cancel button</name>
  <files>src/components/ScanProgress.tsx, src/app/dashboard/brands/[id]/page.tsx</files>
  <action>
**1. Create `src/components/ScanProgress.tsx`:**

```typescript
'use client';

import { useEffect, useState } from 'react';
import { createClient } from '@/lib/supabase/client';

interface ScanProgressProps {
  scanId: string;
  onComplete?: () => void;
  onError?: (error: string) => void;
  onCancel?: () => void;
}

type ScanStep = 'domains' | 'web' | 'logo' | 'social' | 'finalizing';

const STEP_LABELS: Record<ScanStep, string> = {
  domains: 'Checking domain variations',
  web: 'Scanning web for lookalikes',
  logo: 'Searching for logo usage',
  social: 'Scanning social media',
  finalizing: 'Finalizing results'
};

interface ScanData {
  status: string;
  current_step?: string;
  step_progress?: number;
  step_total?: number;
  overall_progress?: number;
  domains_checked?: number;
  pages_scanned?: number;
  threats_found?: number;
  retry_count?: number;
  error?: string;
}

export function ScanProgress({ scanId, onComplete, onError, onCancel }: ScanProgressProps) {
  const [scan, setScan] = useState<ScanData | null>(null);
  const [polling, setPolling] = useState(true);
  const [cancelling, setCancelling] = useState(false);

  // Cancel scan handler (HARD-04)
  const handleCancel = async () => {
    if (cancelling) return;
    setCancelling(true);

    try {
      const response = await fetch('/api/scan/cancel', {
        method: 'POST',
        headers: { 'Content-Type': 'application/json' },
        body: JSON.stringify({ scanId })
      });

      if (!response.ok) {
        const data = await response.json();
        throw new Error(data.error || 'Failed to cancel scan');
      }

      setPolling(false);
      onCancel?.();
    } catch (err) {
      console.error('Failed to cancel scan:', err);
      // Still allow retry
      setCancelling(false);
    }
  };

  useEffect(() => {
    if (!polling) return;

    const supabase = createClient();
    let timeoutId: NodeJS.Timeout;

    const fetchProgress = async () => {
      const { data, error } = await supabase
        .from('scans')
        .select('status, current_step, step_progress, step_total, overall_progress, domains_checked, pages_scanned, threats_found, retry_count, error')
        .eq('id', scanId)
        .single();

      if (error) {
        console.error('Failed to fetch scan progress:', error);
        return;
      }

      setScan(data);

      if (data.status === 'completed') {
        setPolling(false);
        onComplete?.();
      } else if (data.status === 'failed') {
        setPolling(false);
        onError?.(data.error || 'Scan failed');
      } else {
        // Continue polling
        timeoutId = setTimeout(fetchProgress, 4000);
      }
    };

    fetchProgress();

    return () => {
      if (timeoutId) clearTimeout(timeoutId);
    };
  }, [scanId, polling, onComplete, onError]);

  if (!scan) {
    return (
      <div className="animate-pulse bg-gray-100 rounded-lg p-4">
        <div className="h-4 bg-gray-200 rounded w-1/4 mb-2"></div>
        <div className="h-2 bg-gray-200 rounded"></div>
      </div>
    );
  }

  const progress = scan.overall_progress ?? 0;
  const step = (scan.current_step as ScanStep) || 'domains';
  const stepLabel = STEP_LABELS[step] || 'Scanning...';
  const isRunning = scan.status === 'running' || scan.status === 'queued';
  const retryCount = scan.retry_count || 0;

  return (
    <div className="bg-white border rounded-lg p-4 shadow-sm">
      {/* Header with cancel button */}
      <div className="flex justify-between items-center mb-2">
        <div className="flex items-center gap-2">
          <span className="text-sm font-medium text-gray-700">
            {scan.status === 'running' ? stepLabel : scan.status === 'completed' ? 'Scan Complete' : scan.status === 'queued' ? 'Queued...' : 'Scan Failed'}
          </span>
          {/* Retry indicator (HARD-03 visibility) */}
          {retryCount > 0 && isRunning && (
            <span className="text-xs bg-yellow-100 text-yellow-800 px-2 py-0.5 rounded">
              Retry {retryCount}/3
            </span>
          )}
        </div>
        <div className="flex items-center gap-3">
          <span className="text-sm font-semibold text-indigo-600">
            {progress}%
          </span>
          {/* Cancel button (HARD-04) */}
          {isRunning && (
            <button
              onClick={handleCancel}
              disabled={cancelling}
              className="text-xs px-2 py-1 text-red-600 hover:text-red-800 hover:bg-red-50 rounded transition-colors disabled:opacity-50 disabled:cursor-not-allowed"
              title="Cancel scan"
            >
              {cancelling ? 'Cancelling...' : 'Cancel'}
            </button>
          )}
        </div>
      </div>

      {/* Progress bar */}
      <div className="w-full bg-gray-200 rounded-full h-2.5 mb-3">
        <div
          className={`h-2.5 rounded-full transition-all duration-500 ${
            scan.status === 'failed' ? 'bg-red-500' :
            scan.status === 'completed' ? 'bg-green-500' : 'bg-indigo-500'
          }`}
          style={{ width: `${progress}%` }}
        />
      </div>

      {/* Step progress detail */}
      {scan.status === 'running' && scan.step_total && scan.step_total > 0 && (
        <div className="text-xs text-gray-500 mb-2">
          Step progress: {scan.step_progress || 0} / {scan.step_total}
        </div>
      )}

      {/* Stats */}
      <div className="flex gap-4 text-xs text-gray-600">
        {scan.domains_checked !== undefined && scan.domains_checked > 0 && (
          <span>Domains: {scan.domains_checked}</span>
        )}
        {scan.pages_scanned !== undefined && scan.pages_scanned > 0 && (
          <span>Pages: {scan.pages_scanned}</span>
        )}
        {scan.threats_found !== undefined && scan.threats_found > 0 && (
          <span className="text-red-600 font-medium">Threats: {scan.threats_found}</span>
        )}
      </div>

      {/* Error message */}
      {scan.status === 'failed' && scan.error && (
        <div className="mt-2 text-sm text-red-600 bg-red-50 p-2 rounded">
          {scan.error}
        </div>
      )}
    </div>
  );
}
```

**2. Update `src/app/dashboard/brands/[id]/page.tsx`:**

Find where the scan status is displayed (likely a polling component or status indicator).

Import the new component:
```typescript
import { ScanProgress } from '@/components/ScanProgress';
```

Replace or augment the existing scan status display with ScanProgress:
```typescript
{activeScan && (
  <ScanProgress
    scanId={activeScan.id}
    onComplete={() => {
      // Refresh threats list or other UI updates
      router.refresh();
    }}
    onError={(error) => {
      console.error('Scan failed:', error);
    }}
    onCancel={() => {
      // Optionally refresh to show cancelled state
      router.refresh();
    }}
  />
)}
```

Note: The exact integration depends on how the page currently tracks active scans. Look for:
- `useState` tracking a scan ID
- Polling logic for scan status
- UI elements showing "Scanning..." or progress indicators

The ScanProgress component handles its own polling, so you can remove any existing polling logic for scan status if it exists.
  </action>
  <verify>
    - `ls src/components/ScanProgress.tsx` file exists
    - `grep -n "ScanProgress" src/app/dashboard/brands/*/page.tsx` shows import
    - `grep -n "overall_progress" src/components/ScanProgress.tsx` shows progress display
    - `grep -n "api/scan/cancel" src/components/ScanProgress.tsx` shows cancel integration
    - `grep -n "retry_count" src/components/ScanProgress.tsx` shows retry display
  </verify>
  <done>
    - ScanProgress.tsx exists with percentage progress bar
    - Component displays current_step as human-readable label
    - Component shows step progress (X/Y) when available
    - Component shows retry status badge when retrying (HARD-03)
    - Component has cancel button calling /api/scan/cancel (HARD-04)
    - Brand page imports and uses ScanProgress component
  </done>
</task>

<task type="checkpoint:human-verify" gate="blocking">
  <what-built>Complete scan hardening with rate-limited queues, progress UI, retry display, and cancel button</what-built>
  <how-to-verify>
    1. Start the dev server: `npm run dev`
    2. Navigate to a brand page: http://localhost:3000/dashboard/brands/[brand-id]
    3. Trigger a scan (Run Scan button)
    4. Observe the ScanProgress component:
       - Should show percentage (0-100%)
       - Should show current step label (e.g., "Checking domain variations")
       - Progress bar should animate as scan progresses
       - Stats should update (Domains: X, Pages: Y, Threats: Z)
       - Cancel button should be visible during running scan
    5. Test cancel functionality:
       - Click "Cancel" button during scan
       - Should show "Cancelling..." briefly
       - Scan should stop and show "Scan Failed" with "Cancelled by user" message
    6. Wait for a complete scan - progress should reach 100%
    7. Check browser console for any errors

    Note: If database migration not applied, run `supabase db push` first.
  </how-to-verify>
  <resume-signal>Type "approved" or describe issues</resume-signal>
</task>

</tasks>

<verification>
1. Queue integration in scanners:
   - `grep -n "dnsQueue" src/lib/domain-generator.ts`
   - `grep -n "screenshotQueue" src/lib/evidence-collector.ts`
   - `grep -n "externalQueue" src/lib/evidence-collector.ts`
2. ScanProgress component:
   - `ls src/components/ScanProgress.tsx`
   - `grep -n "overall_progress" src/components/ScanProgress.tsx`
   - `grep -n "api/scan/cancel" src/components/ScanProgress.tsx`
   - `grep -n "retry_count" src/components/ScanProgress.tsx`
3. TypeScript compiles: `npx tsc --noEmit src/lib/domain-generator.ts src/lib/evidence-collector.ts src/components/ScanProgress.tsx`
4. Visual verification: Manual test of scan with progress display and cancel
</verification>

<success_criteria>
- domain-generator.ts uses dnsQueue.add() for DNS lookups in checkDomainRegistration
- evidence-collector.ts uses screenshotQueue.add() for screenshots in captureScreenshot
- evidence-collector.ts uses externalQueue.add() for WHOIS in getWhoisData
- ScanProgress.tsx displays percentage progress bar
- ScanProgress.tsx shows current step label
- ScanProgress.tsx shows retry status badge when retry_count > 0 (HARD-03)
- ScanProgress.tsx has cancel button calling POST /api/scan/cancel (HARD-04)
- Brand page integrates ScanProgress for active scans
- User verifies progress display, cancel button, and retry indicator work during scan
</success_criteria>

<output>
After completion, create `.planning/phases/02-scanning-hardening/02-03-SUMMARY.md`
</output>
