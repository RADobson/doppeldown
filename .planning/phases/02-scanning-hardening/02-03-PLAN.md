---
phase: 02-scanning-hardening
plan: 03
type: execute
wave: 3
depends_on: ["02-02"]
files_modified:
  - src/lib/domain-generator.ts
  - src/lib/evidence-collector.ts
  - src/app/dashboard/brands/[id]/page.tsx
  - src/components/ScanProgress.tsx
autonomous: false

must_haves:
  truths:
    - "DNS checks in domain-generator use dnsQueue for rate limiting"
    - "Screenshot captures use screenshotQueue for rate limiting"
    - "UI shows scan progress as percentage with current step"
    - "User can see which step the scan is on (domains, web, logo, social)"
  artifacts:
    - path: "src/lib/domain-generator.ts"
      provides: "Rate-limited DNS checks"
      contains: "dnsQueue"
    - path: "src/lib/evidence-collector.ts"
      provides: "Rate-limited screenshot capture"
      contains: "screenshotQueue"
    - path: "src/components/ScanProgress.tsx"
      provides: "Progress UI component"
      exports: ["ScanProgress"]
  key_links:
    - from: "src/lib/domain-generator.ts"
      to: "src/lib/scan-queue.ts"
      via: "import dnsQueue"
      pattern: "dnsQueue\\.add"
    - from: "src/lib/evidence-collector.ts"
      to: "src/lib/scan-queue.ts"
      via: "import screenshotQueue"
      pattern: "screenshotQueue\\.add"
    - from: "src/components/ScanProgress.tsx"
      to: "overall_progress"
      via: "percentage display"
      pattern: "overall_progress"
---

<objective>
Integrate rate-limited queues into scanner modules and create progress UI showing percentage and current step.

Purpose: Complete the hardening by ensuring all external API calls go through queues, and users can see real-time progress.

Output: Updated scanners with queue integration, ScanProgress component showing percentage/step
</objective>

<execution_context>
@/home/dobsondev/.claude/get-shit-done/workflows/execute-plan.md
@/home/dobsondev/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/02-scanning-hardening/02-RESEARCH.md
@.planning/phases/02-scanning-hardening/02-CONTEXT.md
@src/lib/scan-queue.ts
@src/lib/domain-generator.ts
@src/lib/evidence-collector.ts
</context>

<tasks>

<task type="auto">
  <name>Task 1: Integrate queues into domain-generator and evidence-collector</name>
  <files>src/lib/domain-generator.ts, src/lib/evidence-collector.ts</files>
  <action>
**1. Update domain-generator.ts:**

Add import at top:
```typescript
import { dnsQueue } from './scan-queue';
```

Find the `checkDomainRegistration` function. It likely uses DNS over HTTPS to check if a domain is registered. Wrap the fetch call with dnsQueue:

```typescript
export async function checkDomainRegistration(domain: string): Promise<boolean> {
  // Wrap the DNS lookup in rate-limited queue
  return dnsQueue.add(async () => {
    // ... existing implementation
  }) as Promise<boolean>;
}
```

If the function already does the check inline (not via fetch), create a queue-wrapped version:
```typescript
async function dnsLookupWithQueue(domain: string): Promise<boolean> {
  return dnsQueue.add(async () => {
    // existing DNS lookup logic
  }) as Promise<boolean>;
}
```

**2. Update evidence-collector.ts:**

Add import at top:
```typescript
import { screenshotQueue, externalQueue } from './scan-queue';
```

Find the screenshot capture function (likely `captureScreenshot` or similar). Wrap Puppeteer calls:
```typescript
export async function captureScreenshot(url: string): Promise<ScreenshotResult> {
  return screenshotQueue.add(async () => {
    // ... existing Puppeteer screenshot logic
  }) as Promise<ScreenshotResult>;
}
```

Find the WHOIS lookup function (likely `lookupWhois` or similar). Wrap with externalQueue:
```typescript
async function lookupWhois(domain: string): Promise<WhoisData | null> {
  return externalQueue.add(async () => {
    // ... existing whois-json lookup
  }) as Promise<WhoisData | null>;
}
```

Note: The queues handle rate limiting automatically. The function signatures remain the same - callers don't need to change.
  </action>
  <verify>
    - `grep -n "dnsQueue" src/lib/domain-generator.ts` shows import and usage
    - `grep -n "screenshotQueue" src/lib/evidence-collector.ts` shows import and usage
    - `npx tsc --noEmit src/lib/domain-generator.ts src/lib/evidence-collector.ts` compiles
  </verify>
  <done>
    - domain-generator.ts uses dnsQueue for DNS lookups
    - evidence-collector.ts uses screenshotQueue for Puppeteer operations
    - evidence-collector.ts uses externalQueue for WHOIS lookups
    - All files compile without TypeScript errors
  </done>
</task>

<task type="auto">
  <name>Task 2: Create ScanProgress component with percentage and step display</name>
  <files>src/components/ScanProgress.tsx, src/app/dashboard/brands/[id]/page.tsx</files>
  <action>
**1. Create `src/components/ScanProgress.tsx`:**

```typescript
'use client';

import { useEffect, useState } from 'react';
import { createClient } from '@/lib/supabase/client';

interface ScanProgressProps {
  scanId: string;
  onComplete?: () => void;
  onError?: (error: string) => void;
}

type ScanStep = 'domains' | 'web' | 'logo' | 'social' | 'finalizing';

const STEP_LABELS: Record<ScanStep, string> = {
  domains: 'Checking domain variations',
  web: 'Scanning web for lookalikes',
  logo: 'Searching for logo usage',
  social: 'Scanning social media',
  finalizing: 'Finalizing results'
};

interface ScanData {
  status: string;
  current_step?: string;
  step_progress?: number;
  step_total?: number;
  overall_progress?: number;
  domains_checked?: number;
  pages_scanned?: number;
  threats_found?: number;
  error?: string;
}

export function ScanProgress({ scanId, onComplete, onError }: ScanProgressProps) {
  const [scan, setScan] = useState<ScanData | null>(null);
  const [polling, setPolling] = useState(true);

  useEffect(() => {
    if (!polling) return;

    const supabase = createClient();
    let timeoutId: NodeJS.Timeout;

    const fetchProgress = async () => {
      const { data, error } = await supabase
        .from('scans')
        .select('status, current_step, step_progress, step_total, overall_progress, domains_checked, pages_scanned, threats_found, error')
        .eq('id', scanId)
        .single();

      if (error) {
        console.error('Failed to fetch scan progress:', error);
        return;
      }

      setScan(data);

      if (data.status === 'completed') {
        setPolling(false);
        onComplete?.();
      } else if (data.status === 'failed') {
        setPolling(false);
        onError?.(data.error || 'Scan failed');
      } else {
        // Continue polling
        timeoutId = setTimeout(fetchProgress, 4000);
      }
    };

    fetchProgress();

    return () => {
      if (timeoutId) clearTimeout(timeoutId);
    };
  }, [scanId, polling, onComplete, onError]);

  if (!scan) {
    return (
      <div className="animate-pulse bg-gray-100 rounded-lg p-4">
        <div className="h-4 bg-gray-200 rounded w-1/4 mb-2"></div>
        <div className="h-2 bg-gray-200 rounded"></div>
      </div>
    );
  }

  const progress = scan.overall_progress ?? 0;
  const step = (scan.current_step as ScanStep) || 'domains';
  const stepLabel = STEP_LABELS[step] || 'Scanning...';

  return (
    <div className="bg-white border rounded-lg p-4 shadow-sm">
      {/* Header */}
      <div className="flex justify-between items-center mb-2">
        <span className="text-sm font-medium text-gray-700">
          {scan.status === 'running' ? stepLabel : scan.status === 'completed' ? 'Scan Complete' : 'Scan Failed'}
        </span>
        <span className="text-sm font-semibold text-indigo-600">
          {progress}%
        </span>
      </div>

      {/* Progress bar */}
      <div className="w-full bg-gray-200 rounded-full h-2.5 mb-3">
        <div
          className={`h-2.5 rounded-full transition-all duration-500 ${
            scan.status === 'failed' ? 'bg-red-500' :
            scan.status === 'completed' ? 'bg-green-500' : 'bg-indigo-500'
          }`}
          style={{ width: `${progress}%` }}
        />
      </div>

      {/* Step progress detail */}
      {scan.status === 'running' && scan.step_total && scan.step_total > 0 && (
        <div className="text-xs text-gray-500 mb-2">
          Step progress: {scan.step_progress || 0} / {scan.step_total}
        </div>
      )}

      {/* Stats */}
      <div className="flex gap-4 text-xs text-gray-600">
        {scan.domains_checked !== undefined && scan.domains_checked > 0 && (
          <span>Domains: {scan.domains_checked}</span>
        )}
        {scan.pages_scanned !== undefined && scan.pages_scanned > 0 && (
          <span>Pages: {scan.pages_scanned}</span>
        )}
        {scan.threats_found !== undefined && scan.threats_found > 0 && (
          <span className="text-red-600 font-medium">Threats: {scan.threats_found}</span>
        )}
      </div>

      {/* Error message */}
      {scan.status === 'failed' && scan.error && (
        <div className="mt-2 text-sm text-red-600 bg-red-50 p-2 rounded">
          {scan.error}
        </div>
      )}
    </div>
  );
}
```

**2. Update `src/app/dashboard/brands/[id]/page.tsx`:**

Find where the scan status is displayed (likely a polling component or status indicator).

Import the new component:
```typescript
import { ScanProgress } from '@/components/ScanProgress';
```

Replace or augment the existing scan status display with ScanProgress:
```typescript
{activeScan && (
  <ScanProgress
    scanId={activeScan.id}
    onComplete={() => {
      // Refresh threats list or other UI updates
      router.refresh();
    }}
    onError={(error) => {
      console.error('Scan failed:', error);
    }}
  />
)}
```

Note: The exact integration depends on how the page currently tracks active scans. Look for:
- `useState` tracking a scan ID
- Polling logic for scan status
- UI elements showing "Scanning..." or progress indicators

The ScanProgress component handles its own polling, so you can remove any existing polling logic for scan status if it exists.
  </action>
  <verify>
    - `ls src/components/ScanProgress.tsx` file exists
    - `grep -n "ScanProgress" src/app/dashboard/brands/*/page.tsx` shows import
    - `grep -n "overall_progress" src/components/ScanProgress.tsx` shows progress display
  </verify>
  <done>
    - ScanProgress.tsx exists with percentage progress bar
    - Component displays current_step as human-readable label
    - Component shows step progress (X/Y) when available
    - Brand page imports and uses ScanProgress component
  </done>
</task>

<task type="checkpoint:human-verify" gate="blocking">
  <what-built>Complete scan hardening with rate-limited queues and progress UI</what-built>
  <how-to-verify>
    1. Start the dev server: `npm run dev`
    2. Navigate to a brand page: http://localhost:3000/dashboard/brands/[brand-id]
    3. Trigger a scan (Run Scan button)
    4. Observe the ScanProgress component:
       - Should show percentage (0-100%)
       - Should show current step label (e.g., "Checking domain variations")
       - Progress bar should animate as scan progresses
       - Stats should update (Domains: X, Pages: Y, Threats: Z)
    5. Wait for scan to complete - progress should reach 100%
    6. Check browser console for any errors

    Note: If database migration not applied, run `supabase db push` first.
  </how-to-verify>
  <resume-signal>Type "approved" or describe issues</resume-signal>
</task>

</tasks>

<verification>
1. Queue integration in scanners:
   - `grep -n "dnsQueue" src/lib/domain-generator.ts`
   - `grep -n "screenshotQueue" src/lib/evidence-collector.ts`
2. ScanProgress component:
   - `ls src/components/ScanProgress.tsx`
   - `grep -n "overall_progress" src/components/ScanProgress.tsx`
3. TypeScript compiles: `npx tsc --noEmit src/lib/domain-generator.ts src/lib/evidence-collector.ts src/components/ScanProgress.tsx`
4. Visual verification: Manual test of scan with progress display
</verification>

<success_criteria>
- domain-generator.ts uses dnsQueue.add() for DNS lookups
- evidence-collector.ts uses screenshotQueue.add() for screenshots
- evidence-collector.ts uses externalQueue.add() for WHOIS
- ScanProgress.tsx displays percentage progress bar
- ScanProgress.tsx shows current step label
- Brand page integrates ScanProgress for active scans
- User verifies progress display works during scan
</success_criteria>

<output>
After completion, create `.planning/phases/02-scanning-hardening/02-03-SUMMARY.md`
</output>
