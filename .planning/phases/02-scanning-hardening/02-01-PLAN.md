---
phase: 02-scanning-hardening
plan: 01
type: execute
wave: 1
depends_on: []
files_modified:
  - package.json
  - src/lib/scan-queue.ts
  - src/lib/api-client.ts
autonomous: true

must_haves:
  truths:
    - "Rate-limited queues exist with per-provider limits"
    - "Fetch wrapper handles timeout, retry, and 429 responses"
    - "p-queue dependency installed and importable"
  artifacts:
    - path: "src/lib/scan-queue.ts"
      provides: "Rate-limited queue exports"
      exports: ["dnsQueue", "searchQueue", "screenshotQueue", "openaiQueue"]
    - path: "src/lib/api-client.ts"
      provides: "Fetch wrapper with retry"
      exports: ["fetchWithRetry"]
  key_links:
    - from: "src/lib/scan-queue.ts"
      to: "p-queue"
      via: "import PQueue"
      pattern: "import PQueue from 'p-queue'"
    - from: "src/lib/api-client.ts"
      to: "AbortSignal"
      via: "native timeout"
      pattern: "AbortSignal\\.timeout"
---

<objective>
Create foundational infrastructure for scan hardening: rate-limited queues and retry-capable fetch wrapper.

Purpose: These utilities will be used by scan-runner and all scanner modules to handle API calls safely without crashing scans or triggering rate limits.

Output: scan-queue.ts (queue exports), api-client.ts (fetch wrapper), p-queue installed
</objective>

<execution_context>
@/home/dobsondev/.claude/get-shit-done/workflows/execute-plan.md
@/home/dobsondev/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/02-scanning-hardening/02-RESEARCH.md
@.planning/phases/02-scanning-hardening/02-CONTEXT.md
</context>

<tasks>

<task type="auto">
  <name>Task 1: Install p-queue and create scan-queue.ts</name>
  <files>package.json, src/lib/scan-queue.ts</files>
  <action>
1. Install p-queue:
   ```bash
   npm install p-queue
   ```

2. Create `src/lib/scan-queue.ts` with rate-limited queues:

```typescript
/**
 * Rate-limited queues for external API calls during scanning.
 * Each queue respects provider-specific rate limits.
 */
import PQueue from 'p-queue';

// DNS lookups (Google/Cloudflare DNS over HTTPS)
// Conservative: 10 requests/second
export const dnsQueue = new PQueue({
  concurrency: 5,
  interval: 1000,
  intervalCap: 10
});

// Web search API (DuckDuckGo, SerpAPI)
// Conservative: 2 requests/second
export const searchQueue = new PQueue({
  concurrency: 2,
  interval: 1000,
  intervalCap: 2
});

// Screenshot capture (Puppeteer - memory intensive)
// Serial: 1 request/2 seconds
export const screenshotQueue = new PQueue({
  concurrency: 1,
  interval: 2000,
  intervalCap: 1
});

// OpenAI API calls (Vision analysis)
// Tier-dependent: 50 requests/minute conservative
export const openaiQueue = new PQueue({
  concurrency: 3,
  interval: 60000,
  intervalCap: 50
});

// General external API calls (WHOIS, etc.)
// Moderate: 5 requests/second
export const externalQueue = new PQueue({
  concurrency: 3,
  interval: 1000,
  intervalCap: 5
});

// Helper to wait for all queues to clear (useful for graceful shutdown)
export async function waitForAllQueues(): Promise<void> {
  await Promise.all([
    dnsQueue.onIdle(),
    searchQueue.onIdle(),
    screenshotQueue.onIdle(),
    openaiQueue.onIdle(),
    externalQueue.onIdle()
  ]);
}

// Helper to clear all pending tasks (for cancellation)
export function clearAllQueues(): void {
  dnsQueue.clear();
  searchQueue.clear();
  screenshotQueue.clear();
  openaiQueue.clear();
  externalQueue.clear();
}
```
  </action>
  <verify>
    - `npm ls p-queue` shows p-queue installed
    - `npx tsc --noEmit src/lib/scan-queue.ts` compiles without errors
  </verify>
  <done>
    - p-queue in package.json dependencies
    - scan-queue.ts exports 5 queues + 2 helpers
  </done>
</task>

<task type="auto">
  <name>Task 2: Create api-client.ts with retry and timeout</name>
  <files>src/lib/api-client.ts</files>
  <action>
Create `src/lib/api-client.ts` with fetch wrapper that handles:
- Configurable timeout via AbortSignal.timeout()
- Exponential backoff with full jitter
- 429 rate limit handling with Retry-After header
- 5xx server error retry
- Error capture without throwing (for wrap-and-continue pattern)

```typescript
/**
 * HTTP client with retry, timeout, and rate limit handling.
 * Used by scanner modules for safe external API calls.
 */

// Read timeout from env or default to 10s
const DEFAULT_TIMEOUT_MS = parseInt(process.env.SCAN_NETWORK_TIMEOUT_MS || '10000', 10);
const DEFAULT_MAX_RETRIES = 3;
const MAX_BACKOFF_MS = 30000;

export type FetchResult<T> =
  | { success: true; data: T; response: Response }
  | { success: false; error: string; retryable: boolean };

export interface FetchOptions extends Omit<RequestInit, 'signal'> {
  timeoutMs?: number;
  maxRetries?: number;
  // If provided, can cancel the request externally
  abortSignal?: AbortSignal;
}

/**
 * Sleep helper with optional abort
 */
function sleep(ms: number, signal?: AbortSignal): Promise<void> {
  return new Promise((resolve, reject) => {
    const timer = setTimeout(resolve, ms);
    if (signal) {
      signal.addEventListener('abort', () => {
        clearTimeout(timer);
        reject(new Error('Sleep aborted'));
      }, { once: true });
    }
  });
}

/**
 * Calculate backoff with full jitter
 * Base: 1s, 2s, 4s, 8s... capped at MAX_BACKOFF_MS
 */
function calculateBackoff(attempt: number): number {
  const baseDelay = Math.min(MAX_BACKOFF_MS, 1000 * Math.pow(2, attempt));
  // Full jitter: random between 0 and baseDelay
  return Math.random() * baseDelay;
}

/**
 * Parse Retry-After header (seconds or HTTP-date)
 */
function parseRetryAfter(header: string | null): number {
  if (!header) return 5000; // Default 5s

  const seconds = parseInt(header, 10);
  if (!isNaN(seconds)) return seconds * 1000;

  // Try HTTP-date
  const date = new Date(header);
  if (!isNaN(date.getTime())) {
    return Math.max(0, date.getTime() - Date.now());
  }

  return 5000;
}

/**
 * Fetch with automatic retry, timeout, and rate limit handling.
 * Returns a result object instead of throwing - enables wrap-and-continue pattern.
 */
export async function fetchWithRetry(
  url: string,
  options: FetchOptions = {}
): Promise<FetchResult<Response>> {
  const {
    timeoutMs = DEFAULT_TIMEOUT_MS,
    maxRetries = DEFAULT_MAX_RETRIES,
    abortSignal,
    ...fetchOptions
  } = options;

  let lastError = 'Unknown error';
  let retryable = false;

  for (let attempt = 0; attempt <= maxRetries; attempt++) {
    try {
      // Create timeout signal
      const timeoutSignal = AbortSignal.timeout(timeoutMs);

      // Combine with external abort signal if provided
      const combinedSignal = abortSignal
        ? AbortSignal.any([timeoutSignal, abortSignal])
        : timeoutSignal;

      const response = await fetch(url, {
        ...fetchOptions,
        signal: combinedSignal
      });

      // Handle rate limiting
      if (response.status === 429) {
        const retryAfterMs = parseRetryAfter(response.headers.get('retry-after'));
        lastError = `Rate limited (429), retry after ${retryAfterMs}ms`;
        retryable = true;

        if (attempt < maxRetries) {
          await sleep(retryAfterMs, abortSignal);
          continue;
        }
        break;
      }

      // Handle server errors (5xx) with retry
      if (response.status >= 500) {
        lastError = `Server error (${response.status})`;
        retryable = true;

        if (attempt < maxRetries) {
          const backoff = calculateBackoff(attempt);
          await sleep(backoff, abortSignal);
          continue;
        }
        break;
      }

      // Success or client error (4xx except 429)
      return {
        success: true,
        data: response,
        response
      };

    } catch (err) {
      // Handle abort
      if (err instanceof Error) {
        if (err.name === 'AbortError' || err.message.includes('aborted')) {
          return {
            success: false,
            error: 'Request aborted',
            retryable: false
          };
        }

        if (err.name === 'TimeoutError' || err.message.includes('timeout')) {
          lastError = `Request timeout (${timeoutMs}ms)`;
          retryable = true;
        } else {
          lastError = err.message;
          retryable = true; // Network errors are typically retryable
        }
      }

      if (attempt < maxRetries) {
        const backoff = calculateBackoff(attempt);
        try {
          await sleep(backoff, abortSignal);
        } catch {
          // Sleep was aborted
          return {
            success: false,
            error: 'Request aborted during backoff',
            retryable: false
          };
        }
      }
    }
  }

  return {
    success: false,
    error: lastError,
    retryable
  };
}

/**
 * Convenience wrapper that parses JSON response
 */
export async function fetchJson<T>(
  url: string,
  options: FetchOptions = {}
): Promise<FetchResult<T>> {
  const result = await fetchWithRetry(url, options);

  if (!result.success) {
    return result;
  }

  try {
    const data = await result.data.json() as T;
    return {
      success: true,
      data,
      response: result.response
    };
  } catch (err) {
    return {
      success: false,
      error: `Failed to parse JSON: ${err instanceof Error ? err.message : 'Unknown'}`,
      retryable: false
    };
  }
}
```
  </action>
  <verify>
    - `npx tsc --noEmit src/lib/api-client.ts` compiles without errors
  </verify>
  <done>
    - api-client.ts exports fetchWithRetry and fetchJson
    - Handles timeout, retry, 429, and abort signals
  </done>
</task>

</tasks>

<verification>
1. p-queue installed: `npm ls p-queue`
2. Both files compile: `npx tsc --noEmit src/lib/scan-queue.ts src/lib/api-client.ts`
3. Exports are correct: Grep for export statements in both files
</verification>

<success_criteria>
- p-queue ^8.0.1 in package.json dependencies
- scan-queue.ts has 5 queue exports (dnsQueue, searchQueue, screenshotQueue, openaiQueue, externalQueue)
- api-client.ts has fetchWithRetry and fetchJson exports
- Both files compile without TypeScript errors
</success_criteria>

<output>
After completion, create `.planning/phases/02-scanning-hardening/02-01-SUMMARY.md`
</output>
