---
phase: 02-scanning-hardening
plan: 02
type: execute
wave: 2
depends_on: ["02-01"]
files_modified:
  - supabase/migrations/20260125000001_add_scan_progress_fields.sql
  - src/types/index.ts
  - src/lib/scan-runner.ts
  - scripts/scan-worker.ts
autonomous: true

must_haves:
  truths:
    - "Scans table has current_step, step_progress, step_total, overall_progress, partial_errors, retry_count columns"
    - "Scan runner uses rate-limited queues for all external API calls"
    - "Errors are captured in partial_errors instead of crashing scan"
    - "Progress percentage is calculated and updated during scan"
    - "Retry count is synced from scan_jobs.attempts to scans.retry_count"
  artifacts:
    - path: "supabase/migrations/20260125000001_add_scan_progress_fields.sql"
      provides: "Progress schema migration"
      contains: "retry_count"
    - path: "src/lib/scan-runner.ts"
      provides: "Hardened scan orchestration"
      contains: "dnsQueue"
  key_links:
    - from: "src/lib/scan-runner.ts"
      to: "src/lib/scan-queue.ts"
      via: "import"
      pattern: "import.*from.*scan-queue"
    - from: "src/lib/scan-runner.ts"
      to: "supabase.from('scans')"
      via: "progress update"
      pattern: "overall_progress"
    - from: "scripts/scan-worker.ts"
      to: "scans.retry_count"
      via: "sync attempts"
      pattern: "retry_count.*attempts"
---

<objective>
Add progress schema fields (including retry tracking) and refactor scan-runner to use rate-limited queues with error aggregation.

Purpose: Enable real-time progress percentage tracking, retry visibility, and prevent individual API failures from crashing entire scans.

Output: Migration with progress + retry fields, hardened scan-runner using queues, scan-worker syncing retry count
</objective>

<execution_context>
@/home/dobsondev/.claude/get-shit-done/workflows/execute-plan.md
@/home/dobsondev/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/02-scanning-hardening/02-RESEARCH.md
@.planning/phases/02-scanning-hardening/02-CONTEXT.md
@src/lib/scan-runner.ts
@src/lib/scan-queue.ts
@src/lib/api-client.ts
@scripts/scan-worker.ts
</context>

<tasks>

<task type="auto">
  <name>Task 1: Add progress and retry schema fields migration</name>
  <files>supabase/migrations/20260125000001_add_scan_progress_fields.sql, src/types/index.ts</files>
  <action>
1. Create migration `supabase/migrations/20260125000001_add_scan_progress_fields.sql`:

```sql
-- Add detailed progress tracking and retry visibility to scans table
-- Enables real-time progress percentage, error aggregation, and retry status

-- Add step tracking columns
ALTER TABLE scans ADD COLUMN IF NOT EXISTS current_step TEXT;
ALTER TABLE scans ADD COLUMN IF NOT EXISTS step_progress INTEGER DEFAULT 0;
ALTER TABLE scans ADD COLUMN IF NOT EXISTS step_total INTEGER DEFAULT 0;
ALTER TABLE scans ADD COLUMN IF NOT EXISTS overall_progress INTEGER DEFAULT 0;

-- Add error aggregation column (JSONB array of error objects)
ALTER TABLE scans ADD COLUMN IF NOT EXISTS partial_errors JSONB DEFAULT '[]'::jsonb;

-- Add retry tracking (synced from scan_jobs.attempts for UI visibility)
-- HARD-03: Failed scans auto-retry - this column lets UI show "Retry 2/3"
ALTER TABLE scans ADD COLUMN IF NOT EXISTS retry_count INTEGER DEFAULT 0;

-- Add column comments for documentation
COMMENT ON COLUMN scans.current_step IS 'Current scan phase: domains, web, logo, social, evidence';
COMMENT ON COLUMN scans.step_progress IS 'Items completed in current step';
COMMENT ON COLUMN scans.step_total IS 'Total items in current step';
COMMENT ON COLUMN scans.overall_progress IS 'Overall scan progress 0-100 percentage';
COMMENT ON COLUMN scans.partial_errors IS 'Array of non-fatal errors that occurred during scan';
COMMENT ON COLUMN scans.retry_count IS 'Number of retry attempts (synced from scan_jobs.attempts)';
```

2. Update `src/types/index.ts` to include new Scan fields:
   - Find the `Scan` interface/type
   - Add: `current_step?: string`
   - Add: `step_progress?: number`
   - Add: `step_total?: number`
   - Add: `overall_progress?: number`
   - Add: `partial_errors?: ScanError[]`
   - Add: `retry_count?: number`
   - Add new `ScanError` type:

```typescript
export type ScanError = {
  type: string;        // 'dns_check', 'screenshot', 'whois', etc.
  target?: string;     // Domain or URL that failed
  error: string;       // Error message
  timestamp: string;   // ISO timestamp
  retryable: boolean;  // Whether this error could be retried
};
```
  </action>
  <verify>
    - Migration file exists with all 6 new columns (including retry_count)
    - Types include ScanError and updated Scan interface with retry_count
  </verify>
  <done>
    - Migration adds current_step, step_progress, step_total, overall_progress, partial_errors, retry_count
    - Scan type updated with new fields including retry_count
    - ScanError type defined
  </done>
</task>

<task type="auto">
  <name>Task 2: Refactor scan-runner and scan-worker for progress and retry tracking</name>
  <files>src/lib/scan-runner.ts, scripts/scan-worker.ts</files>
  <action>
**Part A: Refactor scan-runner.ts**

**1. Add imports at top:**
```typescript
import { dnsQueue, screenshotQueue, clearAllQueues } from './scan-queue';
import type { ScanError } from '../types';
```

**2. Add progress calculation helper after type definitions:**
```typescript
type ScanStep = 'domains' | 'web' | 'logo' | 'social' | 'finalizing';

const STEP_WEIGHTS: Record<ScanStep, number> = {
  domains: 40,
  web: 25,
  logo: 15,
  social: 20,
  finalizing: 0
};

function calculateOverallProgress(
  step: ScanStep,
  stepProgress: number,
  stepTotal: number,
  mode: ScanMode
): number {
  // Calculate enabled step weights
  const enabledWeights: Partial<Record<ScanStep, number>> = {};
  if (mode.domains) enabledWeights.domains = STEP_WEIGHTS.domains;
  if (mode.web) enabledWeights.web = STEP_WEIGHTS.web;
  if (mode.logo) enabledWeights.logo = STEP_WEIGHTS.logo;
  if (mode.social) enabledWeights.social = STEP_WEIGHTS.social;

  const totalWeight = Object.values(enabledWeights).reduce((a, b) => a + b, 0);
  if (totalWeight === 0) return 100;

  // Calculate cumulative progress from completed steps
  const stepOrder: ScanStep[] = ['domains', 'web', 'logo', 'social'];
  let cumulativeProgress = 0;
  let reachedCurrentStep = false;

  for (const s of stepOrder) {
    if (s === step) {
      reachedCurrentStep = true;
      // Add partial progress for current step
      const stepWeight = enabledWeights[s] || 0;
      const stepPercent = stepTotal > 0 ? (stepProgress / stepTotal) : 0;
      cumulativeProgress += (stepWeight / totalWeight) * stepPercent * 100;
      break;
    }
    if (!reachedCurrentStep && enabledWeights[s]) {
      // Add full weight for completed steps
      cumulativeProgress += (enabledWeights[s]! / totalWeight) * 100;
    }
  }

  return Math.min(100, Math.round(cumulativeProgress));
}
```

**3. Add errors array at start of runScanForBrand (after threats declaration):**
```typescript
const partialErrors: ScanError[] = [];
```

**4. Modify the updateProgress function to include step tracking:**
Replace the existing updateProgress function with:
```typescript
const updateProgress = async (
  step: ScanStep,
  stepProg: number,
  stepTot: number,
  force: boolean = false
) => {
  const nowMs = Date.now();
  if (!force && nowMs - lastProgressUpdate < PROGRESS_UPDATE_INTERVAL_MS) return;
  lastProgressUpdate = nowMs;

  const overallProgress = calculateOverallProgress(step, stepProg, stepTot, mode);

  try {
    await supabase
      .from('scans')
      .update({
        status: 'running',
        current_step: step,
        step_progress: stepProg,
        step_total: stepTot,
        overall_progress: overallProgress,
        domains_checked: domainsChecked,
        pages_scanned: pagesScanned,
        threats_found: threatsFound,
        partial_errors: partialErrors
      })
      .eq('id', scanId);
  } catch (err) {
    console.warn('Failed to update scan progress:', err);
  }
};
```

**5. Modify domain checking loop to use dnsQueue:**
Find the domain variation loop (`for (const variation of variationsToCheck)`) and wrap the checkDomainRegistration call:

```typescript
for (const variation of variationsToCheck) {
  try {
    // Use rate-limited queue for DNS check
    const isRegistered = await dnsQueue.add(async () => {
      return await checkDomainRegistration(variation.domain);
    });

    domainsChecked++;
    // ... rest of existing logic
  } catch (err) {
    // Capture error but continue
    partialErrors.push({
      type: 'dns_check',
      target: variation.domain,
      error: err instanceof Error ? err.message : 'Unknown error',
      timestamp: new Date().toISOString(),
      retryable: true
    });
    domainsChecked++; // Count even failures
    // Continue to next domain - don't crash scan
  }

  // Update progress with step info
  await updateProgress('domains', domainsChecked, variationsToCheck.length);

  // ... existing cancellation check
}
```

**6. Add similar pattern to web scanning section:**
Wrap web scanner calls and capture errors:
```typescript
if (mode.web) {
  await ensureNotCancelled();
  await updateProgress('web', 0, 1, true);

  try {
    const webThreats = await scanForThreats(/* ... existing args ... */);
    // ... process webThreats
  } catch (err) {
    partialErrors.push({
      type: 'web_scan',
      error: err instanceof Error ? err.message : 'Unknown error',
      timestamp: new Date().toISOString(),
      retryable: true
    });
    // Continue to logo/social scanning
  }
  await updateProgress('web', 1, 1, true);
}
```

**7. Add similar pattern to logo scanning section:**
```typescript
if (mode.logo && brand.logo_url) {
  await ensureNotCancelled();
  await updateProgress('logo', 0, 1, true);

  try {
    const logoResults = await searchLogoUsage(brand.logo_url);
    // ... process logoResults
  } catch (err) {
    partialErrors.push({
      type: 'logo_scan',
      error: err instanceof Error ? err.message : 'Unknown error',
      timestamp: new Date().toISOString(),
      retryable: true
    });
  }
  await updateProgress('logo', 1, 1, true);
}
```

**8. Add similar pattern to social scanning section:**
```typescript
if (mode.social) {
  await ensureNotCancelled();
  await updateProgress('social', 0, 1, true);

  try {
    const socialThreats = await scanSocialMedia(/* ... */);
    // ... process socialThreats
  } catch (err) {
    partialErrors.push({
      type: 'social_scan',
      error: err instanceof Error ? err.message : 'Unknown error',
      timestamp: new Date().toISOString(),
      retryable: true
    });
  }
  await updateProgress('social', 1, 1, true);
}
```

**9. Update final scan completion to set 100% and include errors:**
```typescript
await supabase
  .from('scans')
  .update({
    status: 'completed',
    completed_at: new Date().toISOString(),
    threats_found: threatsFound,
    domains_checked: domainsChecked,
    pages_scanned: pagesScanned,
    overall_progress: 100,
    current_step: 'finalizing',
    step_progress: 1,
    step_total: 1,
    partial_errors: partialErrors
  })
  .eq('id', scanId);
```

**10. Add queue cleanup on cancellation:**
In the catch block handling cancellation, add:
```typescript
} catch (error) {
  // Clear queues on error/cancellation
  clearAllQueues();

  await supabase
    .from('scans')
    .update({
      status: 'failed',
      completed_at: new Date().toISOString(),
      error: error instanceof Error ? error.message : 'Unknown error',
      partial_errors: partialErrors
    })
    .eq('id', scanId);

  throw error;
}
```

**Part B: Update scan-worker.ts to sync retry_count**

Find the `failOrRetryJob` function (around line 83). After updating scan_jobs status, also update the scans table retry_count:

**1. In the retry branch (when shouldRetry is true), add after the scan_jobs update:**
```typescript
// Sync retry count to scans table for UI visibility (HARD-03)
if (job.scan_id) {
  await supabase
    .from('scans')
    .update({ retry_count: attempts + 1 })
    .eq('id', job.scan_id);
}
```

**2. In the processJob function, at the start of processing, sync the current attempt:**
After fetching the brand, add:
```typescript
// Sync current attempt count to scans table
if (job.scan_id) {
  await supabase
    .from('scans')
    .update({ retry_count: job.attempts || 0 })
    .eq('id', job.scan_id);
}
```
  </action>
  <verify>
    - `npx tsc --noEmit src/lib/scan-runner.ts` compiles without errors
    - `npx tsc --noEmit scripts/scan-worker.ts` compiles without errors
    - Grep for "dnsQueue" in scan-runner.ts shows import and usage
    - Grep for "overall_progress" in scan-runner.ts shows progress tracking
    - Grep for "partialErrors" in scan-runner.ts shows error aggregation
    - Grep for "retry_count" in scan-worker.ts shows sync to scans table
  </verify>
  <done>
    - scan-runner.ts imports and uses dnsQueue from scan-queue.ts
    - Progress calculation with step weights implemented
    - updateProgress sends current_step, step_progress, step_total, overall_progress
    - Errors captured in partialErrors array, saved to DB
    - Queue cleanup on cancellation/error
    - scan-worker.ts syncs retry_count from scan_jobs.attempts to scans.retry_count
  </done>
</task>

</tasks>

<verification>
1. Migration file exists: `ls supabase/migrations/*progress*.sql`
2. TypeScript compiles: `npx tsc --noEmit src/lib/scan-runner.ts src/types/index.ts scripts/scan-worker.ts`
3. Queue integration: `grep -n "dnsQueue" src/lib/scan-runner.ts`
4. Progress tracking: `grep -n "overall_progress" src/lib/scan-runner.ts`
5. Error aggregation: `grep -n "partialErrors" src/lib/scan-runner.ts`
6. Retry sync: `grep -n "retry_count" scripts/scan-worker.ts`
</verification>

<success_criteria>
- Migration adds 6 new columns to scans table (including retry_count)
- ScanError type exists in types/index.ts
- scan-runner.ts imports from scan-queue.ts
- Domain checking uses dnsQueue.add() wrapper
- updateProgress sends step info (current_step, step_progress, step_total, overall_progress)
- Errors captured to partialErrors array
- Final completion sets overall_progress: 100
- scan-worker.ts syncs retry_count to scans table when retrying
</success_criteria>

<output>
After completion, create `.planning/phases/02-scanning-hardening/02-02-SUMMARY.md`
</output>
