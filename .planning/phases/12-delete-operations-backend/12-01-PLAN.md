---
phase: 12-delete-operations-backend
plan: 01
type: execute
wave: 1
depends_on: []
files_modified:
  - supabase/migrations/20260129000001_add_delete_rls_policies.sql
  - src/app/api/scans/[id]/route.ts
  - src/app/api/threats/[id]/route.ts
  - src/app/api/reports/[id]/route.ts
autonomous: true

must_haves:
  truths:
    - "DELETE /api/scans/:id removes the scan and its associated threats from the database"
    - "DELETE /api/threats/:id removes the threat record and cleans up evidence files from storage"
    - "DELETE /api/reports/:id removes the report record from the database"
    - "All three endpoints return 404 for non-existent or non-owned resources"
    - "All three endpoints write audit log entries before performing deletion"
    - "Unauthenticated requests return 401, wrong-owner requests return 404"
  artifacts:
    - path: "supabase/migrations/20260129000001_add_delete_rls_policies.sql"
      provides: "RLS DELETE policies for threats, scans, and reports tables"
      contains: "CREATE POLICY"
    - path: "src/app/api/scans/[id]/route.ts"
      provides: "DELETE endpoint for scans with manual threat cascade and audit logging"
      exports: ["DELETE"]
    - path: "src/app/api/threats/[id]/route.ts"
      provides: "DELETE endpoint for threats with storage file cleanup and audit logging"
      exports: ["DELETE"]
    - path: "src/app/api/reports/[id]/route.ts"
      provides: "DELETE endpoint for reports with audit logging"
      exports: ["DELETE"]
  key_links:
    - from: "src/app/api/scans/[id]/route.ts"
      to: "src/lib/audit-logger.ts"
      via: "logAudit() call before deletion"
      pattern: "logAudit\\("
    - from: "src/app/api/threats/[id]/route.ts"
      to: "src/lib/audit-logger.ts"
      via: "logAudit() call before deletion"
      pattern: "logAudit\\("
    - from: "src/app/api/reports/[id]/route.ts"
      to: "src/lib/audit-logger.ts"
      via: "logAudit() call before deletion"
      pattern: "logAudit\\("
    - from: "src/app/api/scans/[id]/route.ts"
      to: "supabase threats table"
      via: "manual delete of associated threats before scan deletion"
      pattern: "\\.from\\('threats'\\).*\\.delete\\("
---

<objective>
Create DELETE API endpoints for scans, threats, and reports with RLS policies, ownership verification, audit logging, and proper cascade handling.

Purpose: Enable users to delete their own data via API, completing the backend foundation for Phase 13 delete UI.
Output: Three DELETE endpoints at /api/scans/[id], /api/threats/[id], /api/reports/[id] plus RLS migration.
</objective>

<execution_context>
@/home/dobsondev/.claude/get-shit-done/workflows/execute-plan.md
@/home/dobsondev/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/11-audit-logging-infrastructure/11-01-SUMMARY.md
@.planning/phases/12-delete-operations-backend/12-RESEARCH.md

Key codebase references:
@src/lib/audit-logger.ts — logAudit() function (best-effort, never throws)
@src/lib/supabase/server.ts — createClient() and createServiceClient()
@src/app/api/scan/route.ts — existing auth + ownership pattern to follow
@src/app/api/reports/route.ts — existing report handling pattern
@src/types/index.ts — Threat, Evidence, ScreenshotEvidence, AuditAction, AuditEntityType types
@supabase/schema.sql — foreign key relationships (CRITICAL: threats.scan_id → scans.id is ON DELETE SET NULL, NOT CASCADE)
</context>

<tasks>

<task type="auto">
  <name>Task 1: Add DELETE RLS policies for threats, scans, and reports</name>
  <files>supabase/migrations/20260129000001_add_delete_rls_policies.sql</files>
  <action>
Create a new migration file that adds DELETE RLS policies for the three tables that currently lack them: threats, scans, and reports.

Each policy follows the existing ownership-via-brand pattern already used for SELECT/INSERT/UPDATE on these tables (see schema.sql lines 200-283). The pattern uses an EXISTS subquery checking that the row's brand_id belongs to a brand owned by auth.uid().

SQL content:
```sql
-- Add DELETE policies for threats, scans, and reports
-- These tables have SELECT/INSERT/UPDATE policies but no DELETE policies

CREATE POLICY "Users can delete threats for own brands" ON public.threats
    FOR DELETE USING (
        EXISTS (
            SELECT 1 FROM public.brands
            WHERE brands.id = threats.brand_id
            AND brands.user_id = auth.uid()
        )
    );

CREATE POLICY "Users can delete scans for own brands" ON public.scans
    FOR DELETE USING (
        EXISTS (
            SELECT 1 FROM public.brands
            WHERE brands.id = scans.brand_id
            AND brands.user_id = auth.uid()
        )
    );

CREATE POLICY "Users can delete reports for own brands" ON public.reports
    FOR DELETE USING (
        EXISTS (
            SELECT 1 FROM public.brands
            WHERE brands.id = reports.brand_id
            AND brands.user_id = auth.uid()
        )
    );
```

No IF NOT EXISTS for policies (Postgres doesn't support it). If policies already exist, migration will fail cleanly.
  </action>
  <verify>File exists at supabase/migrations/20260129000001_add_delete_rls_policies.sql with three CREATE POLICY statements. TypeScript build still passes: `npx next build` (migration is SQL-only, shouldn't affect TS build).</verify>
  <done>DELETE RLS policies exist for threats, scans, and reports tables, matching the existing ownership-via-brand pattern used by other policies.</done>
</task>

<task type="auto">
  <name>Task 2: Create DELETE API endpoints for scans, threats, and reports</name>
  <files>
    src/app/api/scans/[id]/route.ts
    src/app/api/threats/[id]/route.ts
    src/app/api/reports/[id]/route.ts
  </files>
  <action>
Create three DELETE endpoint files. All follow the same pattern: authenticate → fetch+verify ownership → collect metadata → audit log → delete → return success. Key differences noted below.

CRITICAL SCHEMA FACT: `threats.scan_id REFERENCES scans(id) ON DELETE SET NULL`. Deleting a scan does NOT cascade-delete its threats — it only nullifies their scan_id. The phase requirement says "removes scan and associated threats/evidence from DB", so the scan delete endpoint MUST explicitly delete associated threats before deleting the scan.

**All three endpoints share this pattern:**
```typescript
import { NextRequest, NextResponse } from 'next/server'
import { createClient } from '@/lib/supabase/server'
import { logAudit } from '@/lib/audit-logger'

export async function DELETE(
  request: NextRequest,
  { params }: { params: Promise<{ id: string }> }
) {
  // Note: Next.js 14+ App Router params is a Promise that must be awaited
  const { id } = await params
  // ... auth, fetch, ownership check, audit, delete
}
```

IMPORTANT: In Next.js 14 App Router, `params` is a Promise. Must `await params` to get the id value. See Next.js docs on dynamic route segments.

---

**1. DELETE /api/scans/[id]/route.ts**

Flow:
1. Authenticate via supabase.auth.getUser() — 401 if no user
2. Fetch scan with `brands!inner(user_id)` join — 404 if not found or not owned
3. Query threats count for this scan: `.from('threats').select('id', { count: 'exact', head: true }).eq('scan_id', id)`
4. Collect evidence storage paths from associated threats (for best-effort cleanup):
   - Query: `.from('threats').select('evidence').eq('scan_id', id)`
   - Extract storage_path values from evidence.screenshots arrays
5. Best-effort storage file cleanup using createServiceClient() if any storage paths found
6. Call logAudit() with entity_type 'scan', include `{ brand_id, scan_type, cascade_threats_count }` in metadata
7. Delete associated threats: `.from('threats').delete().eq('scan_id', id)` — MUST happen before scan delete
8. Delete the scan: `.from('scans').delete().eq('id', id)`
9. Return `{ success: true }`

Imports: `createClient` AND `createServiceClient` (for storage cleanup)

---

**2. DELETE /api/threats/[id]/route.ts**

Flow:
1. Authenticate — 401 if no user
2. Fetch threat with `brands!inner(user_id)` join and include evidence field — 404 if not found or not owned
3. Extract storage paths from `threat.evidence?.screenshots?.filter(s => s.storage_path).map(s => s.storage_path) || []`
4. Best-effort storage cleanup using createServiceClient():
   - Bucket: `threat.evidence?.storage_bucket || process.env.SUPABASE_EVIDENCE_BUCKET || 'evidence'`
   - Call `storageClient.storage.from(bucket).remove(storagePaths)`
   - Log errors but continue on failure
5. Call logAudit() with entity_type 'threat', include `{ brand_id, threat_type: threat.type, severity: threat.severity, url: threat.url, evidence_files_deleted: storagePaths.length }` in metadata
6. Delete threat: `.from('threats').delete().eq('id', id)`
7. Return `{ success: true }`

Imports: `createClient` AND `createServiceClient` (for storage cleanup)

---

**3. DELETE /api/reports/[id]/route.ts**

Flow:
1. Authenticate — 401 if no user
2. Fetch report with `brands!inner(user_id)` join — 404 if not found or not owned
3. Call logAudit() with entity_type 'report', include `{ brand_id, report_type }` in metadata (use whatever columns exist on the report; check the select fields)
4. Delete report: `.from('reports').delete().eq('id', id)`
5. Return `{ success: true }`

Imports: `createClient` only (no storage cleanup needed — reports generated on-demand)

---

**Error handling for all endpoints:**
- Outer try-catch wrapping entire handler
- Auth errors: return 401
- Fetch errors or not found: return 404 (do NOT distinguish 403 from 404 — prevents resource enumeration)
- Delete errors: throw to outer catch → return 500 with generic message
- Console.error with context for all caught errors

**Response format for all:** `NextResponse.json({ success: true })` on success. `NextResponse.json({ error: 'message' }, { status: N })` on failure.
  </action>
  <verify>
1. All three files exist: `ls src/app/api/scans/[id]/route.ts src/app/api/threats/[id]/route.ts src/app/api/reports/[id]/route.ts`
2. TypeScript build passes: `npx next build`
3. Each file exports a DELETE function
4. Each file imports logAudit from '@/lib/audit-logger'
5. Scan endpoint includes `.from('threats').delete()` call (manual cascade)
6. Threat endpoint includes `storage.from(bucket).remove()` call (evidence cleanup)
  </verify>
  <done>
Three DELETE endpoints exist and pass TypeScript compilation. Scans endpoint manually deletes associated threats before scan deletion (since FK is SET NULL, not CASCADE). Threats endpoint cleans up storage files best-effort. Reports endpoint does simple DB deletion. All three call logAudit() before deletion and return proper HTTP status codes (401/404/500/200).
  </done>
</task>

</tasks>

<verification>
1. `npx next build` completes without errors
2. All four files exist: migration SQL + 3 route.ts files
3. Each route.ts exports async function DELETE
4. Each route.ts calls logAudit() with correct entity_type
5. Scan route explicitly deletes threats before scan (handles SET NULL FK)
6. Threat route handles evidence storage cleanup with service client
7. grep confirms all three routes import from '@/lib/audit-logger'
</verification>

<success_criteria>
- Migration adds DELETE RLS policies for threats, scans, reports
- DELETE /api/scans/:id authenticates, verifies ownership, audits, deletes threats then scan
- DELETE /api/threats/:id authenticates, verifies ownership, cleans storage, audits, deletes threat
- DELETE /api/reports/:id authenticates, verifies ownership, audits, deletes report
- All endpoints return 401 for unauthenticated, 404 for missing/unowned, 200 for success
- TypeScript build passes cleanly
</success_criteria>

<output>
After completion, create `.planning/phases/12-delete-operations-backend/12-01-SUMMARY.md`
</output>
