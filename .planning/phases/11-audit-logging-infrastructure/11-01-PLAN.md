---
phase: 11-audit-logging-infrastructure
plan: 01
type: execute
wave: 1
depends_on: []
files_modified:
  - supabase/migrations/20260129000000_add_audit_logs.sql
  - src/types/index.ts
  - src/lib/audit-logger.ts
  - src/app/api/admin/audit-logs/route.ts
autonomous: true

must_haves:
  truths:
    - "Delete actions are logged with user_id, user_email, entity_type, entity_id, and timestamp"
    - "Audit logs persist independently of deleted entities (no cascade delete on audit_logs)"
    - "Admin users can query audit logs via API with optional filters"
    - "Non-admin users cannot read audit logs"
    - "Audit log failures do not block delete operations (best-effort logging)"
  artifacts:
    - path: "supabase/migrations/20260129000000_add_audit_logs.sql"
      provides: "audit_logs table with RLS policies"
      contains: "CREATE TABLE IF NOT EXISTS public.audit_logs"
    - path: "src/types/index.ts"
      provides: "AuditLog TypeScript interface"
      contains: "export interface AuditLog"
    - path: "src/lib/audit-logger.ts"
      provides: "logAudit service function"
      exports: ["logAudit"]
    - path: "src/app/api/admin/audit-logs/route.ts"
      provides: "Admin-only GET endpoint for audit log queries"
      exports: ["GET"]
  key_links:
    - from: "src/lib/audit-logger.ts"
      to: "supabase audit_logs table"
      via: "createServiceClient insert"
      pattern: "supabase.*from\\('audit_logs'\\).*insert"
    - from: "src/app/api/admin/audit-logs/route.ts"
      to: "supabase audit_logs table"
      via: "createClient select with admin check"
      pattern: "is_admin.*audit_logs"
---

<objective>
Create the audit logging infrastructure: database table, TypeScript types, service function, and admin query endpoint.

Purpose: Foundation for accountability — Phase 12 delete endpoints will call logAudit() before every delete operation. This phase ensures the infrastructure exists and is queryable.
Output: Migration SQL, AuditLog type, logAudit() function, admin API endpoint.
</objective>

<execution_context>
@/home/dobsondev/.claude/get-shit-done/workflows/execute-plan.md
@/home/dobsondev/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/11-audit-logging-infrastructure/11-RESEARCH.md

Key codebase references:
@supabase/migrations/20260128000001_add_notifications.sql — Follow this pattern for migration structure (CREATE TABLE, indexes, RLS, policies)
@src/types/index.ts — Append AuditLog interface here (follow Notification interface pattern)
@src/lib/supabase/server.ts — Use createServiceClient() for audit writes (bypasses RLS), createClient() for admin reads (respects RLS)
@src/app/api/notifications/route.ts — Follow this pattern for API route structure (auth check, query, response)
</context>

<tasks>

<task type="auto">
  <name>Task 1: Create audit_logs table migration and TypeScript types</name>
  <files>
    supabase/migrations/20260129000000_add_audit_logs.sql
    src/types/index.ts
  </files>
  <action>
    **Migration SQL** (`supabase/migrations/20260129000000_add_audit_logs.sql`):
    Create `public.audit_logs` table following the notifications migration pattern:

    Columns:
    - `id` UUID PRIMARY KEY DEFAULT gen_random_uuid()
    - `user_id` UUID NOT NULL REFERENCES auth.users(id) ON DELETE SET NULL — SET NULL not CASCADE so audit persists if user deleted
    - `user_email` TEXT — redundant with user_id but persists if user account deleted
    - `action` TEXT NOT NULL CHECK (action IN ('DELETE')) — extensible for future actions
    - `entity_type` TEXT NOT NULL CHECK (entity_type IN ('scan', 'threat', 'report'))
    - `entity_id` UUID NOT NULL — no FK reference since entity will be deleted
    - `metadata` JSONB DEFAULT '{}' — brand_id, cascade info, etc.
    - `created_at` TIMESTAMPTZ NOT NULL DEFAULT NOW()

    Indexes:
    - `idx_audit_logs_user_id` on (user_id)
    - `idx_audit_logs_entity` on (entity_type, entity_id)
    - `idx_audit_logs_created_at` on (created_at DESC)

    RLS:
    - Enable RLS on audit_logs
    - "Admins can view all audit logs" — SELECT policy using EXISTS subquery on public.users WHERE is_admin = TRUE
    - "Service can insert audit logs" — INSERT policy WITH CHECK (TRUE) — service role bypasses RLS anyway but explicit policy is cleaner

    **TypeScript types** (append to `src/types/index.ts`):
    Add AuditLog interface and AuditAction/AuditEntityType types:

    ```typescript
    export type AuditAction = 'DELETE'
    export type AuditEntityType = 'scan' | 'threat' | 'report'

    export interface AuditLog {
      id: string
      user_id: string
      user_email?: string
      action: AuditAction
      entity_type: AuditEntityType
      entity_id: string
      metadata: Record<string, unknown>
      created_at: string
    }
    ```

    IMPORTANT: user_id FK uses ON DELETE SET NULL (not CASCADE) so audit records survive user deletion.
  </action>
  <verify>
    1. `cat supabase/migrations/20260129000000_add_audit_logs.sql` shows valid SQL with CREATE TABLE, indexes, RLS, and policies
    2. `npx tsc --noEmit` passes (TypeScript compiles with new types)
  </verify>
  <done>
    audit_logs migration exists with correct schema, indexes, RLS policies. AuditLog type exported from src/types/index.ts.
  </done>
</task>

<task type="auto">
  <name>Task 2: Create audit logger service function</name>
  <files>
    src/lib/audit-logger.ts
  </files>
  <action>
    Create `src/lib/audit-logger.ts` with a `logAudit()` function:

    ```typescript
    import { createServiceClient } from './supabase/server'
    import type { AuditAction, AuditEntityType } from '../types'

    interface AuditLogEntry {
      user_id: string
      user_email?: string
      action: AuditAction
      entity_type: AuditEntityType
      entity_id: string
      metadata?: Record<string, unknown>
    }

    export async function logAudit(entry: AuditLogEntry): Promise<void> {
      try {
        const supabase = await createServiceClient()

        const { error } = await supabase
          .from('audit_logs')
          .insert({
            user_id: entry.user_id,
            user_email: entry.user_email,
            action: entry.action,
            entity_type: entry.entity_type,
            entity_id: entry.entity_id,
            metadata: entry.metadata || {},
          })

        if (error) {
          console.error('Failed to write audit log:', error)
        }
      } catch (err) {
        // Best-effort: audit failure must not block delete operations
        console.error('Audit logging error:', err)
      }
    }
    ```

    Key design decisions:
    - Uses `createServiceClient()` (service role key) to bypass RLS for inserts
    - Wraps in try/catch so audit failures never throw — best-effort pattern per research anti-patterns
    - `created_at` defaults to NOW() in database, not passed from application
    - Types imported from `src/types/index.ts` for consistency
    - Function is async but callers should `await` it (writes before delete, but won't block on failure)
  </action>
  <verify>
    1. `npx tsc --noEmit` passes
    2. File exports `logAudit` function
    3. Function uses `createServiceClient()` (not `createClient()`)
    4. Function catches errors without re-throwing
  </verify>
  <done>
    `logAudit()` exported from `src/lib/audit-logger.ts`. Uses service client, best-effort (non-blocking on failure), type-safe entry parameter.
  </done>
</task>

<task type="auto">
  <name>Task 3: Create admin audit log query endpoint</name>
  <files>
    src/app/api/admin/audit-logs/route.ts
  </files>
  <action>
    Create `src/app/api/admin/audit-logs/route.ts` with GET handler:

    Follow the existing API route pattern from `src/app/api/notifications/route.ts`:

    ```typescript
    import { NextRequest, NextResponse } from 'next/server'
    import { createClient } from '@/lib/supabase/server'

    export async function GET(request: NextRequest) {
      try {
        const supabase = await createClient()

        // 1. Authenticate
        const { data: { user }, error: authError } = await supabase.auth.getUser()
        if (authError || !user) {
          return NextResponse.json({ error: 'Unauthorized' }, { status: 401 })
        }

        // 2. Verify admin
        const { data: userData } = await supabase
          .from('users')
          .select('is_admin')
          .eq('id', user.id)
          .single()

        if (!userData?.is_admin) {
          return NextResponse.json({ error: 'Forbidden' }, { status: 403 })
        }

        // 3. Parse query params for filtering
        const { searchParams } = new URL(request.url)
        const entityType = searchParams.get('entity_type')
        const userId = searchParams.get('user_id')
        const limit = Math.min(parseInt(searchParams.get('limit') || '100'), 500)
        const offset = parseInt(searchParams.get('offset') || '0')

        // 4. Build query
        let query = supabase
          .from('audit_logs')
          .select('*', { count: 'exact' })
          .order('created_at', { ascending: false })
          .range(offset, offset + limit - 1)

        if (entityType) {
          query = query.eq('entity_type', entityType)
        }
        if (userId) {
          query = query.eq('user_id', userId)
        }

        const { data: logs, error, count } = await query

        if (error) throw error

        return NextResponse.json({
          logs: logs || [],
          total: count || 0,
          limit,
          offset
        })
      } catch (error) {
        console.error('Error fetching audit logs:', error)
        return NextResponse.json(
          { error: 'Failed to fetch audit logs' },
          { status: 500 }
        )
      }
    }
    ```

    Key details:
    - Admin check uses `!userData?.is_admin` pattern (consistent with existing admin bypass pattern)
    - Uses `createClient()` (not service client) — RLS policy on audit_logs requires is_admin
    - Supports query params: `entity_type`, `user_id`, `limit` (max 500), `offset`
    - Returns paginated response with `total` count
    - Max limit capped at 500 to prevent abuse
    - Create the `src/app/api/admin/` directory if it doesn't exist
  </action>
  <verify>
    1. `npx tsc --noEmit` passes
    2. File exports GET function
    3. Admin check pattern: `!userData?.is_admin`
    4. Uses `createClient()` (user-scoped, respects RLS)
    5. Build succeeds: `npm run build` completes without errors on this route
  </verify>
  <done>
    Admin-only GET /api/admin/audit-logs endpoint returns paginated audit logs with optional entity_type and user_id filters. Non-admins get 403.
  </done>
</task>

</tasks>

<verification>
1. TypeScript compilation: `npx tsc --noEmit` passes with zero errors
2. Build check: `npm run build` succeeds (verifies API route compiles in Next.js context)
3. Migration file exists at `supabase/migrations/20260129000000_add_audit_logs.sql` with correct SQL
4. `src/lib/audit-logger.ts` exports `logAudit` function
5. `src/app/api/admin/audit-logs/route.ts` exports `GET` handler with admin check
6. `src/types/index.ts` contains `AuditLog`, `AuditAction`, `AuditEntityType` exports
</verification>

<success_criteria>
- audit_logs table schema defined in migration with proper indexes and admin-only RLS
- logAudit() function available for Phase 12 delete endpoints to import
- Admin can query audit logs via GET /api/admin/audit-logs with filters
- All TypeScript types are exported and compile cleanly
- No new dependencies required
</success_criteria>

<output>
After completion, create `.planning/phases/11-audit-logging-infrastructure/11-01-SUMMARY.md`
</output>
